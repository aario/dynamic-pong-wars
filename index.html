<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Pong Wars</title>
  <meta name="description" content="Dynamic Pong Wars – a colorful pong game where balls conquer opposing territory.">
  <meta name="author" content="Marko Denic">
  <meta name="theme-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta property="og:title" content="Dynamic Pong Wars">
  <meta property="og:description" content="Play Dynamic Pong Wars – conquer the grid with your balls in a colorful pong battle.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://markodenic.tech">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dynamic Pong Wars">
  <meta name="twitter:description" content="Play Dynamic Pong Wars – conquer the grid with your balls in a colorful pong battle.">

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      background: linear-gradient(to bottom, #000000 0%, #FFFFFF 100%);
    }

    main {
      flex: 1;
      max-width: 600px;
      margin: 0 auto;
      padding: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    #resetBtn, #playPauseBtn, #configBtn {
      position: fixed;
      top: 20px;
      width: 50px;
      height: 50px;
      background: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      cursor: pointer;
      z-index: 1000;
      transition: background 0.2s, transform 0.15s ease;
    }

    #resetBtn { right: 140px; }
    #playPauseBtn { right: 80px; }
    #configBtn { right: 20px; }

    #resetBtn:active, #playPauseBtn:active, #configBtn:active {
      transform: scale(0.97);
    }

    #resetBtn svg, #playPauseBtn svg, #configBtn svg {
      stroke: #000;
      width: 30px;
      height: 30px;
      fill: none;
    }

    #configPanel {
      position: fixed;
      top: 10px;
      right: -280px;
      width: 220px;
      background: #fff;
      padding: 75px 25px 25px;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 999;
      transition: right 0.18s ease-out;
    }

    #configPanel.visible { right: 10px; }

    #configPanel label {
      display: flex;
      flex-direction: column;
      gap: 10px;
      justify-content: space-between;
    }

    canvas {
      width: 100%;
      margin-top: auto;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      display: block;
    }

    #scorePanel {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 200px;
      background: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
      backdrop-filter: blur(4px); /* Optional: nice blur effect */
      color: white;
      padding: 10px;
      border-radius: 8px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      transition: height 0.3s ease;
      overflow: hidden;
    }

    #scorePanel.collapsed {
      height: 30px; /* Only show header when collapsed */
    }

    #scoreHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-weight: bold;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #scoreToggleBtn {
      background: none;
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      cursor: pointer;
      border-radius: 4px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      font-size: 16px;
      line-height: 1;
    }

    #scoreDisplay {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 14px;
      font-weight: bold;
      overflow-y: auto;
      max-height: 400px;
    }

    /* Hide scrollbar for cleaner look */
    #scoreDisplay::-webkit-scrollbar {
      width: 4px;
    }
    #scoreDisplay::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
    }

    footer {
      padding: 15px;
      background: #000;
      color: #fff;
      text-align: center;
      font-size: 14px;
    }

    footer a { color: #ffc600; }
  </style>
</head>
<body>
<div id="scorePanel">
  <div id="scoreHeader">
    <span>Leaderboard</span>
    <button id="scoreToggleBtn">−</button>
  </div>
  <div id="scoreDisplay"></div>
</div>
<div id="resetBtn">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 12v-3a3 3 0 0 1 3 -3h13m-3 -3l3 3l-3 3"/>
    <path d="M20 12v3a3 3 0 0 1 -3 3h-13m3 3l-3 -3l3 -3"/>
  </svg>
</div>

<div id="playPauseBtn" data-playing="true">
  <svg class="play-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 4v16l13 -8z" />
  </svg>
  <svg class="pause-icon" style="display: block;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M6 5h4v14h-4z m8 0h4v14h-4z"/>
  </svg>
</div>

<div id="configBtn">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z"/>
    <path d="M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/>
  </svg>
</div>

<div id="configPanel">
</div>

<main>
  <div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
  </div>
</main>

<footer>
  Made by <a href="https://markodenic.tech" target="_blank">Marko Denic</a>. Improved by <a href="https://aario.info" target="_blank">Aario Shahbany</a>. Source on
  <a href="https://github.com/markodenic/dynamic-pong-wars" target="_blank">GitHub</a>. Inspired by
  <a href="https://github.com/vnglst/pong-wars" target="_blank">Pong Wars</a>.
</footer>

<script>
  const canvas = document.querySelector("#gameCanvas");
  const ctx = canvas.getContext("2d");
  const scoreDisplay = document.querySelector("#scoreDisplay");
  const configBtn = document.querySelector("#configBtn");
  const configPanel = document.querySelector("#configPanel");
  const resetBtn = document.querySelector("#resetBtn");
  const playPauseBtn = document.querySelector("#playPauseBtn");
  const playIcon = playPauseBtn.querySelector(".play-icon");
  const pauseIcon = playPauseBtn.querySelector(".pause-icon");
  const scorePanel = document.querySelector("#scorePanel");
  const scoreToggleBtn = document.querySelector("#scoreToggleBtn");

  const TILE_SIZE = 25;
  const MAX_SPEED = 10;
  const MIN_SPEED = 5;
  const ACCELERATION = 0.1;
  const titles = [
    "Emperor", "Empress", "Warlord", "High Priest", "Grand Vizier", "Star Warden",
    "Abyssal Lord", "Void Walker", "Pixel Paladin", "Byte Baron", "Quantum Sage",
    "Nebula Duke", "Iron Thane", "Sun Eater", "Moon Watcher", "Chrono Master",
    "Archon", "Sovereign", "Dread Knight", "Shah", "Amir", "Sultan"
  ];

  const syllables = [
    "zor", "bax", "quu", "vex", "traz", "lim", "puk", "ha", "sha", "gu",
    "sam", "ov", "xyl", "fon", "dru", "kraz", "ni", "lo", "wa", "ke",
    "xar", "tus", "mon", "rak", "zi", "bo", "fe", "ca", "dor", "mu"
  ];

  function generateFantasyName() {
    const title = titles[Math.floor(Math.random() * titles.length)];
    const numSyllables = 2 + Math.floor(Math.random() * 3); // 2 to 4 syllables
    let name = "";
    for (let i = 0; i < numSyllables; i++) {
      name += syllables[Math.floor(Math.random() * syllables.length)];
    }
    // Capitalize the name part
    name = name.charAt(0).toUpperCase() + name.slice(1);
    return `${title} ${name}`;
  }
  const getRandomColor = () => {
    return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
  };

  const MIN_PLAYER_COUNT = 2;
  const MAX_PLAYER_COUNT = 10;

  // Initialize with a random number between MIN and MAX
  let PLAYER_COUNT = Math.floor(Math.random() * (MAX_PLAYER_COUNT - MIN_PLAYER_COUNT + 1)) + MIN_PLAYER_COUNT;

  let players = [];
  let balls = [];

  for (let i = 0; i < PLAYER_COUNT; i++) {
    players.push({
      id: i,
      name: generateFantasyName(),
      color: getRandomColor(),
      score: 0
    });
  }
  let iteration = 0;
  let isPlaying = true;
  let animationFrameId = null;

  const gridWidth = canvas.width / TILE_SIZE;
  const gridHeight = canvas.height / TILE_SIZE;

  const ownership = new Array(gridWidth * gridHeight).fill(0).map((_, idx) => {
    const col = idx % gridWidth;
    // Divide grid width evenly by player count
    return Math.floor(col / (gridWidth / PLAYER_COUNT));
  });

  const grid = new Array(gridWidth * gridHeight).fill(0).map((_, idx) => ({
    x: (idx % gridWidth) * TILE_SIZE,
    y: Math.floor(idx / gridWidth) * TILE_SIZE,
    get color() {
      // Look up the color dynamically from the players array
      return players[ownership[idx]].color;
    }
  }));

  function toggleConfigPanel() {
    configPanel.classList.toggle("visible");
  }

  function togglePlayPause() {
    isPlaying = !isPlaying;
    playIcon.style.display = isPlaying ? "none" : "block";
    pauseIcon.style.display = isPlaying ? "block" : "none";
    playPauseBtn.dataset.playing = isPlaying;
    if (isPlaying) {
      animationFrameId = requestAnimationFrame(render);
    } else {
      cancelAnimationFrame(animationFrameId);
    }
  }

  function updateBackground() {
    const totalScore = players.reduce((sum, p) => sum + p.score, 0);

    // If game just started (score 0), distribute evenly
    if (totalScore === 0) {
      const colors = players.map(p => p.color).join(', ');
      document.body.style.background = `linear-gradient(to bottom, ${colors})`;
      return;
    }

    let gradientParts = [];
    let currentPercent = 0;

    players.forEach(p => {
      // Calculate the size of this player's share (0 to 100)
      const share = (p.score / totalScore) * 100;

      // Calculate the CENTER point of this player's territory
      const centerPoint = currentPercent + (share / 2);

      // Add a single color stop at the center
      // The browser will automatically fade between these points
      gradientParts.push(`${p.color} ${centerPoint.toFixed(2)}%`);

      currentPercent += share;
    });

    document.body.style.background = `linear-gradient(to bottom, ${gradientParts.join(', ')})`;
  }

  function drawTile(tile) {
    ctx.fillStyle = tile.color;
    ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
  }

  const getRingColor = (hex) => {
    // Remove the hash if it exists
    hex = hex.replace('#', '');

    // Parse the R, G, B values
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);

    // Calculate luminance (perceived brightness)
    // Formula: 0.299*R + 0.587*G + 0.114*B
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b);

    // If luminance > 160 (bright), darken by subtracting. 
    // Otherwise, lighten by adding.
    const change = luminance > 160 ? -80 : 80;

    // Apply change and clamp values between 0 and 255
    r = Math.min(255, Math.max(0, r + change));
    g = Math.min(255, Math.max(0, g + change));
    b = Math.min(255, Math.max(0, b + change));

    // Convert back to Hex
    const toHex = (c) => c.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  };

  function drawBall(ball) {
    ctx.save(); // Save settings so shadow doesn't affect the grid
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, TILE_SIZE / 2, 0, Math.PI * 2);

    // Add a dark shadow behind the ball
    ctx.shadowColor = "rgba(0,0,0,0.5)";
    ctx.shadowBlur = 5;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    ctx.fillStyle = ball.color;
    ctx.fill();

    // Add a thick white border
    ctx.shadowColor = "transparent"; // Turn off shadow for the border
    ctx.lineWidth = 3;

    ctx.strokeStyle = getRingColor(ball.color);
    ctx.stroke();


    ctx.closePath();
    ctx.restore(); // Restore settings
  }

  function detectCollision(ball) {
    const ballRect = {
      left: ball.x - TILE_SIZE / 2,
      right: ball.x + TILE_SIZE / 2,
      top: ball.y - TILE_SIZE / 2,
      bottom: ball.y + TILE_SIZE / 2
    };
    grid.forEach((tile, idx) => {
      const tileRect = {
        left: tile.x,
        right: tile.x + TILE_SIZE,
        top: tile.y,
        bottom: tile.y + TILE_SIZE
      };
      if (
          ballRect.right > tileRect.left &&
          ballRect.left < tileRect.right &&
          ballRect.bottom > tileRect.top &&
          ballRect.top < tileRect.bottom &&
          ownership[idx] !== ball.ownerId
      ) {
        ownership[idx] = ball.ownerId;
        const dx = ball.x - (tile.x + TILE_SIZE / 2);
        const dy = ball.y - (tile.y + TILE_SIZE / 2);
        if (Math.abs(dx) > Math.abs(dy)) {
          ball.vx = -ball.vx;
        } else {
          ball.vy = -ball.vy;
        }
      }
    });
  }

  function checkBoundaries(ball) {
    if (ball.x < TILE_SIZE / 2 || ball.x > canvas.width - TILE_SIZE / 2) {
      ball.vx = -ball.vx;
      ball.x = Math.max(TILE_SIZE / 2, Math.min(canvas.width - TILE_SIZE / 2, ball.x));
    }
    if (ball.y < TILE_SIZE / 2 || ball.y > canvas.height - TILE_SIZE / 2) {
      ball.vy = -ball.vy;
      ball.y = Math.max(TILE_SIZE / 2, Math.min(canvas.height - TILE_SIZE / 2, ball.y));
    }
  }

  function updateBall(ball) {
    ball.vx += (Math.random() - 0.5) * ACCELERATION;
    ball.vy += (Math.random() - 0.5) * ACCELERATION;
    const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);
    if (speed > MAX_SPEED) {
      const scale = MAX_SPEED / speed;
      ball.vx *= scale;
      ball.vy *= scale;
    }
    if (speed < MIN_SPEED) {
      const scale = MIN_SPEED / speed;
      ball.vx *= scale;
      ball.vy *= scale;
    }
    ball.x += ball.vx;
    ball.y += ball.vy;
  }

  function resetGame() {
    // 1. Re-initialize Players Array
    players = [];
    for (let i = 0; i < PLAYER_COUNT; i++) {
      players.push({
        id: i,
        name: generateFantasyName(),
        color: getRandomColor(),
        score: 0
      });
    }

    // 2. Re-initialize Balls Array
    balls = players.map(player => {
      return {
        x: (canvas.width / PLAYER_COUNT) * player.id + (canvas.width / PLAYER_COUNT / 2),
        y: canvas.height / 2,
        vx: (Math.random() > 0.5 ? 1 : -1) * 8,
        vy: (Math.random() > 0.5 ? 1 : -1) * 8,
        ownerId: player.id, 
        get color() { return players[this.ownerId].color; }
      };
    });

    // 3. Reset Grid Ownership based on new PLAYER_COUNT
    ownership.forEach((_, idx) => {
      const col = idx % gridWidth;
      // Divide grid width evenly by player count
      ownership[idx] = Math.floor(col / (gridWidth / PLAYER_COUNT));
      // Clamp to ensure we don't go out of bounds (just in case of rounding errors)
      ownership[idx] = Math.min(ownership[idx], PLAYER_COUNT - 1);
    });

    // 4. Update UI
    createConfigInputs();
    updateBackground();

    iteration = 0;
    if (!isPlaying) togglePlayPause();
  }

  function createConfigInputs() {
    configPanel.innerHTML = ''; // Clear existing

    // --- Add Player Count Control ---
    const countWrapper = document.createElement('div');
    countWrapper.style.marginBottom = "20px";
    countWrapper.style.paddingBottom = "10px";
    countWrapper.style.borderBottom = "1px solid #ddd";

    const countLabel = document.createElement('label');
    countLabel.textContent = `Players (${MIN_PLAYER_COUNT}-${MAX_PLAYER_COUNT}):`;

    const countInput = document.createElement('input');
    countInput.type = "number";
    countInput.min = MIN_PLAYER_COUNT;
    countInput.max = MAX_PLAYER_COUNT;
    countInput.value = PLAYER_COUNT;

    const restartBtn = document.createElement('button');
    restartBtn.textContent = "New Game";
    restartBtn.style.marginTop = "5px";
    restartBtn.style.cursor = "pointer";
    restartBtn.addEventListener('click', () => {
      let val = parseInt(countInput.value);
      // Validate input
      if (val < MIN_PLAYER_COUNT) val = MIN_PLAYER_COUNT;
      if (val > MAX_PLAYER_COUNT) val = MAX_PLAYER_COUNT;

      PLAYER_COUNT = val;
      resetGame(); // This will trigger the full reset with new count
    });

    countLabel.appendChild(countInput);
    countWrapper.appendChild(countLabel);
    countWrapper.appendChild(restartBtn);
    configPanel.appendChild(countWrapper);
    // --------------------------------

    // Generate Color Pickers for current players
    players.forEach(player => {
      const label = document.createElement('label');
      label.style.marginBottom = "10px"; 
      label.textContent = `${player.name} Color: `;

      const input = document.createElement('input');
      input.type = "color";
      input.value = player.color;
      input.addEventListener("input", (e) => {
        player.color = e.target.value;
        updateBackground();
      });

      label.appendChild(input);
      configPanel.appendChild(label);
    });
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Reset scores
    players.forEach(p => p.score = 0);

    // Calculate scores
    grid.forEach((tile, idx) => {
      drawTile(tile);
      if (players[ownership[idx]]) {
        players[ownership[idx]].score++;
      }
    });

    // Sort players by score (Highest first)
    // We create a copy [...players] so we don't mess up the game logic order
    const sortedPlayers = [...players].sort((a, b) => b.score - a.score);

    // Update Display
    scoreDisplay.innerHTML = sortedPlayers.map(p => {
      const ringColor = getRingColor(p.color);
      return `
        <div style="
          color: ${ringColor}; 
          -webkit-text-stroke: 1px ${p.color}; 
          margin-bottom: 4px;
        ">
          ${p.name}: ${p.score}
        </div>
      `;
    }).join('');

    // Update background to match scores
    updateBackground();

    iteration++;
    // Draw and Update Balls
    balls.forEach(ball => {
      drawBall(ball);
      detectCollision(ball);
      checkBoundaries(ball);
      updateBall(ball);
    });
    if (iteration % 1000 === 0) console.log("Iteration:", iteration);
    if (isPlaying) {
      animationFrameId = requestAnimationFrame(render);
    }
  }

  resetGame();
  configBtn.addEventListener("click", toggleConfigPanel);
  resetBtn.addEventListener("click", resetGame);
  playPauseBtn.addEventListener("click", togglePlayPause);
  animationFrameId = requestAnimationFrame(render);
  scoreToggleBtn.addEventListener("click", () => {
    scorePanel.classList.toggle("collapsed");
    // Change button symbol based on state
    scoreToggleBtn.textContent = scorePanel.classList.contains("collapsed") ? "+" : "−";
  });
</script>
</body>
</html>
